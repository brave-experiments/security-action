---
rules:
- id: csharp.dotnet.security.mvc-missing-antiforgery.mvc-missing-antiforgery
  message: "$METHOD is a state-changing MVC method that does not validate the antiforgery
    token or do strict content-type checking. State-changing controller methods should
    either enforce antiforgery tokens or do strict content-type checking to prevent
    simple HTTP request types from bypassing CORS preflight controls."
  severity: WARNING
  metadata:
    likelihood: LOW
    impact: MEDIUM
    confidence: LOW
    category: security
    cwe:
    - 'CWE-352: Cross-Site Request Forgery (CSRF)'
    cwe2021-top25: true
    cwe2022-top25: true
    license: MIT
    owasp:
    - A01:2021 - Broken Access Control
    references:
    - https://cheatsheetseries.owasp.org/cheatsheets/DotNet_Security_Cheat_Sheet.html#cross-site-request-forgery
    - https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests
    subcategory:
    - audit
    technology:
    - ".net"
    - mvc
    source: https://semgrep.dev/r/csharp.dotnet.security.mvc-missing-antiforgery.mvc-missing-antiforgery
    shortlink: https://sg.run/Y0Jy
    semgrep.dev:
      rule:
        rule_id: ZqUlxE
        version_id: JdTwk7
        url: https://semgrep.dev/playground/r/JdTwk7/csharp.dotnet.security.mvc-missing-antiforgery.mvc-missing-antiforgery
  languages:
  - csharp
  patterns:
  - pattern: |
      [$HTTPMETHOD]
      public IActionResult $METHOD(...){
          ...
      }
  - pattern-inside: |
      using Microsoft.AspNetCore.Mvc;
      ...
  - pattern-not: |
      [ValidateAntiForgeryToken]
      public IActionResult $METHOD(...){
          ...
      }
  - pattern-not: |
      [Consumes(...)]
      public IActionResult $METHOD(...){
        ...
      }
  - metavariable-regex:
      metavariable: "$HTTPMETHOD"
      regex: Http(Post|Put|Delete|Patch)
- id: csharp.dotnet.security.web-config-insecure-cookie-settings.web-config-insecure-cookie-settings
  message: Cookie Secure flag is explicitly disabled. You should enforce this value
    to avoid accidentally presenting sensitive cookie values over plaintext HTTP connections.
  severity: WARNING
  metadata:
    likelihood: LOW
    impact: LOW
    confidence: LOW
    category: security
    cwe:
    - 'CWE-614: Sensitive Cookie in HTTPS Session Without ''Secure'' Attribute'
    license: MIT
    owasp:
    - A05:2021 - Security Misconfiguration
    references:
    - https://docs.microsoft.com/en-us/aspnet/web-api/overview/advanced/http-cookies
    - https://docs.microsoft.com/en-us/dotnet/api/system.web.security.formsauthentication.requiressl?redirectedfrom=MSDN&view=netframework-4.8#System_Web_Security_FormsAuthentication_RequireSSL
    - https://docs.microsoft.com/en-us/dotnet/api/system.web.security.roles.cookierequiressl?redirectedfrom=MSDN&view=netframework-4.8#System_Web_Security_Roles_CookieRequireSSL
    subcategory:
    - audit
    technology:
    - ".net"
    - asp
    - webforms
    source: https://semgrep.dev/r/csharp.dotnet.security.web-config-insecure-cookie-settings.web-config-insecure-cookie-settings
    shortlink: https://sg.run/z1jd
    semgrep.dev:
      rule:
        rule_id: 7KUxPg
        version_id: 0bTkG2
        url: https://semgrep.dev/playground/r/0bTkG2/csharp.dotnet.security.web-config-insecure-cookie-settings.web-config-insecure-cookie-settings
  languages:
  - generic
  paths:
    include:
    - "*web.config"
  patterns:
  - pattern-either:
    - pattern: 'requireSSL="false"

        '
    - pattern: 'cookieRequireSSL="false"

        '
  - pattern-either:
    - pattern-inside: "<httpCookies ...>\n"
    - pattern-inside: "<forms ...>\n"
    - pattern-inside: "<roleManager ...>\n"
- id: csharp.lang.security.insecure-deserialization.newtonsoft.insecure-newtonsoft-deserialization
  patterns:
  - pattern-either:
    - pattern: TypeNameHandling = TypeNameHandling.$TYPEHANDLER
    - pattern: |
        $SETTINGS.TypeNameHandling = TypeNameHandling.$TYPEHANDLER;
        ...
        JsonConvert.DeserializeObject<$TYPE>(...,$SETTINGS);
    - pattern: |
        $SETTINGS.TypeNameHandling = TypeNameHandling.$TYPEHANDLER;
        ...
        JsonConvert.DeserializeObject(...,$SETTINGS);
  - pattern-inside: |
      using Newtonsoft.Json;
      ...
  - metavariable-regex:
      metavariable: "$TYPEHANDLER"
      regex: "(All|Auto|Objects|Arrays)"
  message: TypeNameHandling $TYPEHANDLER is unsafe and can lead to arbitrary code
    execution in the context of the process.  Use a custom SerializationBinder whenever
    using a setting other than TypeNameHandling.None.
  languages:
  - csharp
  severity: WARNING
  metadata:
    category: security
    cwe:
    - 'CWE-502: Deserialization of Untrusted Data'
    owasp:
    - A08:2017 - Insecure Deserialization
    - A08:2021 - Software and Data Integrity Failures
    references:
    - https://www.newtonsoft.com/json/help/html/T_Newtonsoft_Json_TypeNameHandling.htm#remarks
    technology:
    - ".net"
    - newtonsoft
    - json
    confidence: LOW
    license: MIT
    cwe2022-top25: true
    cwe2021-top25: true
    subcategory:
    - audit
    likelihood: LOW
    impact: HIGH
    source: https://semgrep.dev/r/csharp.lang.security.insecure-deserialization.newtonsoft.insecure-newtonsoft-deserialization
    shortlink: https://sg.run/8n2g
    semgrep.dev:
      rule:
        rule_id: OrUGgl
        version_id: rxTbNq
        url: https://semgrep.dev/playground/r/rxTbNq/csharp.lang.security.insecure-deserialization.newtonsoft.insecure-newtonsoft-deserialization
- id: raptor-command-injection
  metadata:
    author: Marco Ivaldi <raptor@0xdeadbeef.info>
    references:
    - https://cwe.mitre.org/data/definitions/676
    - https://cwe.mitre.org/data/definitions/78
    - https://cwe.mitre.org/data/definitions/88
    - https://g.co/kgs/PCHQjJ
    - https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf
    confidence: HIGH
    license: MIT
    category: security
    subcategory:
    - audit
    source: https://github.com/0xdea/semgrep-rules/blob/main/c/command-injection.yaml
  message: The program invokes a potentially dangerous function that could introduce
    a vulnerability if it is used incorrectly, but the function can also be used safely.
    The software constructs all or part of an OS command using externally-influenced
    input from an upstream component, but it does not neutralize or incorrectly neutralizes
    special elements that could modify the intended OS command when it is sent to
    a downstream component.
  severity: WARNING
  languages:
  - c
  - cpp
  patterns:
  - pattern-either:
    - pattern: system(...)
    - pattern: popen(...)
  - pattern-not: $FUN("...", ...)
- id: raptor-double-free
  metadata:
    author: Marco Ivaldi <raptor@0xdeadbeef.info>
    references:
    - https://cwe.mitre.org/data/definitions/415
    - https://github.com/struct/mms
    - https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf
    - https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples
    - https://dustri.org/b/playing-with-weggli.html
    confidence: MEDIUM
    license: MIT
    category: security
    subcategory:
    - audit
    source: https://github.com/0xdea/semgrep-rules/blob/main/c/double-free.yaml
  message: The software calls free() twice on the same memory address, potentially
    leading to modification of unexpected memory locations. When a program calls free()
    twice with the same argument, the program's memory management data structures
    become corrupted. This corruption can cause the program to crash or, in some circumstances,
    cause two later calls to malloc() to return the same pointer. If malloc() returns
    the same value twice and the program later gives the attacker control over the
    data that is written into this doubly-allocated memory, the program becomes vulnerable
    to a buffer overflow attack.
  severity: ERROR
  languages:
  - c
  - cpp
  patterns:
  - pattern: |
      free($PTR);
      ...
      free($PTR);
  - pattern-not: |
      free($PTR);
      ...
      $PTR = $EXPR;
      ...
      free($PTR);
- id: raptor-format-string-bugs
  metadata:
    author: Marco Ivaldi <raptor@0xdeadbeef.info>
    references:
    - https://cwe.mitre.org/data/definitions/134
    - https://julianor.tripod.com/bc/formatstring-1.2.pdf
    - http://phrack.org/issues/70/13.html#article
    - https://g.co/kgs/PCHQjJ
    - https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf
    confidence: MEDIUM
    license: MIT
    category: security
    subcategory:
    - audit
    source: https://github.com/0xdea/semgrep-rules/blob/main/c/format-string-bugs.yaml
  message: The software uses a function that accepts a format string as an argument,
    but the format string originates from an external source. When an attacker can
    modify an externally-controlled format string, this can lead to buffer overflows,
    denial of service, or data representation problems. It should be noted that in
    some circumstances, such as internationalization, the set of format strings is
    externally controlled by design. If the source of these format strings is trusted
    (e.g. only contained in library files that are only modifiable by the system administrator),
    then the external control might not itself pose a vulnerability.
  severity: ERROR
  languages:
  - c
  - cpp
  pattern-either:
  - patterns:
    - pattern-either:
      - pattern: printf(...)
      - pattern: vprintf(...)
      - pattern: wprintf(...)
      - pattern: vwprintf(...)
      - pattern: vcprintf(...)
      - pattern: vcwprintf(...)
      - pattern: vscprintf(...)
      - pattern: vscwprintf(...)
      - pattern: printk(...)
      - pattern: scanf(...)
      - pattern: vscanf(...)
      - pattern: wscanf(...)
      - pattern: vwscanf(...)
      - pattern: warn(...)
      - pattern: vwarn(...)
      - pattern: warnx(...)
      - pattern: vwarnx(...)
    - pattern-not: $FUN("...", ...)
  - patterns:
    - pattern-either:
      - pattern: fprintf(...)
      - pattern: vfprintf(...)
      - pattern: fwprintf(...)
      - pattern: vfwprintf(...)
      - pattern: sprintf(...)
      - pattern: vsprintf(...)
      - pattern: asprintf(...)
      - pattern: vasprintf(...)
      - pattern: dprintf(...)
      - pattern: vdprintf(...)
      - pattern: wsprintf(...)
      - pattern: fscanf(...)
      - pattern: vfscanf(...)
      - pattern: fwscanf(...)
      - pattern: vfwscanf(...)
      - pattern: sscanf(...)
      - pattern: vsscanf(...)
      - pattern: swscanf(...)
      - pattern: vswscanf(...)
      - pattern: syslog(...)
      - pattern: vsyslog(...)
      - pattern: err(...)
      - pattern: verr(...)
      - pattern: errx(...)
      - pattern: verrx(...)
      - pattern: warnc(...)
      - pattern: vwarnc(...)
    - pattern-not: $FUN($ARG1, "...", ...)
  - patterns:
    - pattern-either:
      - pattern: snprintf(...)
      - pattern: vsnprintf(...)
      - pattern: swprintf(...)
      - pattern: vswprintf(...)
      - pattern: errc(...)
      - pattern: verrc(...)
    - pattern-not: $FUN($ARG1, $ARG2, "...", ...)
- id: raptor-incorrect-order-setuid-setgid-etc
  metadata:
    author: Marco Ivaldi <raptor@0xdeadbeef.info>
    references:
    - https://cwe.mitre.org/data/definitions/696
    - https://www.usenix.org/legacy/events/sec02/full_papers/chen/chen.pdf
    - https://g.co/kgs/PCHQjJ
    - https://github.com/struct/mms
    confidence: MEDIUM
    license: MIT
    category: security
    subcategory:
    - audit
    source: https://github.com/0xdea/semgrep-rules/blob/main/c/incorrect-order-setuid-setgid-etc.yaml
  message: The software performs multiple related behaviors, but the behaviors are
    performed in the wrong order in ways which may produce resultant weaknesses. The
    set(e)gid() function must be called as root, so the order of the set(e)uid() and
    set(e)gid() calls is important. A compromised process might be able to regain
    elevated group privileges if set(e)gid() is called after set(e)uid(). A similar
    case is when privileges are temporarily dropped with seteuid() and then setuid()
    or seteuid() are called from while under unprivileged user.
  severity: WARNING
  languages:
  - c
  - cpp
  pattern-either:
  - patterns:
    - pattern: |
        setuid(...);
        ...
        setgid(...);
    - pattern-not: |
        setuid(0);
        ...
        setgid(...);
  - patterns:
    - pattern: |
        seteuid(...);
        ...
        setegid(...);
    - pattern-not: |
        seteuid(0);
        ...
        setegid(...);
    - pattern-not-inside: |
        seteuid(...);
        ...
        seteuid(0);
        ...
        setegid(...);
  - patterns:
    - pattern: |
        seteuid(...);
        ...
        setuid(...);
    - pattern-not: |
        seteuid(0);
        ...
        setuid(...);
    - pattern-not-inside: |
        seteuid(...);
        ...
        seteuid(0);
        ...
        setuid(...);
  - patterns:
    - pattern: |
        seteuid(...);
        ...
        seteuid(...);
    - pattern-not: |
        seteuid(0);
        ...
        seteuid(...);
    - pattern-not: |
        seteuid(...);
        ...
        seteuid(0);
    - pattern-not-inside: |
        seteuid(...);
        ...
        seteuid(0);
        ...
        seteuid(...);
- id: raptor-incorrect-unsigned-comparison
  metadata:
    author: Marco Ivaldi <raptor@0xdeadbeef.info>
    references:
    - https://cwe.mitre.org/data/definitions/697
    - https://g.co/kgs/PCHQjJ
    confidence: HIGH
    license: MIT
    category: security
    subcategory:
    - audit
    source: https://github.com/0xdea/semgrep-rules/blob/main/c/incorrect-unsigned-comparison.yaml
  message: The software compares two entities in a security-relevant context, but
    the comparison is incorrect, which may lead to resultant weaknesses. Checking
    if an unsigned variable is negative makes no sense and is usually a good indication
    that something is probably wrong with the code.
  severity: WARNING
  languages:
  - c
  - cpp
  pattern-either:
  - pattern: "(unsigned short $UNSIGNED) < 0"
  - pattern: "(unsigned short int $UNSIGNED) < 0"
  - pattern: "(unsigned int $UNSIGNED) < 0"
  - pattern: "(unsigned long $UNSIGNED) < 0"
  - pattern: "(unsigned long int $UNSIGNED) < 0"
  - pattern: "(size_t $UNSIGNED) < 0"
  - pattern: "(unsigned short $UNSIGNED) <= 0"
  - pattern: "(unsigned short int $UNSIGNED) <= 0"
  - pattern: "(unsigned int $UNSIGNED) <= 0"
  - pattern: "(unsigned long $UNSIGNED) <= 0"
  - pattern: "(unsigned long int $UNSIGNED) <= 0"
  - pattern: "(size_t $UNSIGNED) <= 0"
  - pattern: "(unsigned short $UNSIGNED) >= 0"
  - pattern: "(unsigned short int $UNSIGNED) >= 0"
  - pattern: "(unsigned int $UNSIGNED) >= 0"
  - pattern: "(unsigned long $UNSIGNED) >= 0"
  - pattern: "(unsigned long int $UNSIGNED) >= 0"
  - pattern: "(size_t $UNSIGNED) >= 0"
- id: raptor-incorrect-use-of-sizeof
  metadata:
    author: Marco Ivaldi <raptor@0xdeadbeef.info>
    references:
    - https://cwe.mitre.org/data/definitions/467
    - https://g.co/kgs/PCHQjJ
    - https://github.com/struct/mms
    - https://dustri.org/b/playing-with-weggli.html
    confidence: MEDIUM
    license: MIT
    category: security
    subcategory:
    - audit
    source: https://github.com/0xdea/semgrep-rules/blob/main/c/incorrect-use-of-sizeof.yaml
  message: The code calls sizeof() on a malloced pointer type, which always returns
    the wordsize/8. This can produce an unexpected result if the programmer intended
    to determine how much memory has been allocated. The use of sizeof() on a pointer
    can sometimes generate useful information. An obvious case is to find out the
    wordsize on a platform. More often than not, the appearance of sizeof(pointer)
    indicates a bug.
  severity: WARNING
  languages:
  - c
  - cpp
  pattern-either:
  - patterns:
    - pattern: sizeof((char * $PTR))
    - pattern-not: sizeof("...")
  - pattern: sizeof((int * $PTR))
  - pattern: sizeof((float * $PTR))
  - pattern: sizeof((double * $PTR))
  - patterns:
    - pattern: sizeof($PTR)
    - pattern-either:
      - pattern-inside: |
          $TYPE * $PTR;
          ...
      - pattern-inside: |
          $TYPE * $PTR = $EXPR;
          ...
- id: raptor-incorrect-use-of-strncat
  metadata:
    author: Marco Ivaldi <raptor@0xdeadbeef.info>
    references:
    - https://g.co/kgs/PCHQjJ
    confidence: HIGH
    license: MIT
    category: security
    subcategory:
    - audit
    source: https://github.com/0xdea/semgrep-rules/blob/main/c/incorrect-use-of-strncat.yaml
  message: The strncat() function is intended to be a safe alternative to the strcat()
    function. However, strncat() is nearly as dangerous as strcat(), in that it's
    quite easy to misuse. Specifically, the size parameter can be confusing, as it
    indicates the amount of space left in the buffer. The first common mistake application
    developers make is supplying the size of the entire buffer instead of the size
    remaining in the buffer. A more subtle mistake can be made. The size parameter
    needs to be the amount of space left in the buffer less one; otherwise, the NUL
    byte is written one byte past the end of the buffer.
  severity: WARNING
  languages:
  - c
  - cpp
  pattern-either:
  - patterns:
    - pattern: strncat($DST, $SRC, $LEN)
    - pattern-either:
      - pattern-inside: |
          $TYPE $DST[$LEN];
          ...
      - pattern-inside: |
          $TYPE $DST[$LEN] = $EXPR;
          ...
  - pattern: strncat($DST, $SRC, sizeof($DST))
  - pattern: strncat($DST, $SRC, sizeof($DST) - strlen($DST))
- id: raptor-incorrect-use-of-strncpy-stpncpy-strlcpy
  metadata:
    author: Marco Ivaldi <raptor@0xdeadbeef.info>
    references:
    - https://cwe.mitre.org/data/definitions/806
    - https://github.com/0xdea/advisories/blob/master/2020-07-solaris-whodo-w.txt
    - https://dustri.org/b/playing-with-weggli.html
    confidence: MEDIUM
    license: MIT
    category: security
    subcategory:
    - audit
    source: https://github.com/0xdea/semgrep-rules/blob/main/c/incorrect-use-of-strncpy-stpncpy-strlcpy.yaml
  message: The software uses the size of a source buffer when reading from or writing
    to a destination buffer, which may cause it to access memory that is outside of
    the bounds of the buffer. When the size of the destination is smaller than the
    size of the source, a buffer overflow could occur.
  severity: WARNING
  languages:
  - c
  - cpp
  pattern-either:
  - patterns:
    - pattern: "$FUN($DST, $SRC, $LEN)"
    - metavariable-pattern:
        metavariable: "$FUN"
        pattern-either:
        - pattern: strncpy
        - pattern: stpncpy
        - pattern: strlcpy
    - pattern-either:
      - pattern-inside: |
          $TYPE $SRC[$LEN];
          ...
      - pattern-inside: |
          $TYPE $SRC[$LEN] = $EXPR;
          ...
  - patterns:
    - pattern: "$FUN($DST, $SRC, <... $SRC ...>)"
    - metavariable-pattern:
        metavariable: "$FUN"
        pattern-either:
        - pattern: strncpy
        - pattern: stpncpy
        - pattern: strlcpy
- id: raptor-insecure-api-access-stat-lstat
  metadata:
    author: Marco Ivaldi <raptor@0xdeadbeef.info>
    references:
    - https://cwe.mitre.org/data/definitions/367
    - https://g.co/kgs/PCHQjJ
    confidence: HIGH
    license: MIT
    category: security
    subcategory:
    - audit
    source: https://github.com/0xdea/semgrep-rules/blob/main/c/insecure-api-access-stat-lstat.yaml
  message: The software checks the state of a resource before using that resource,
    but the resource's state can change between the check and the use in a way that
    invalidates the results of the check. This can cause the software to perform invalid
    actions when the resource is in an unexpected state. This weakness can be security-relevant
    when an attacker can influence the state of the resource between check and use.
    This can happen with shared resources such as files, memory, or even variables
    in multithreaded programs.
  severity: WARNING
  languages:
  - c
  - cpp
  pattern-either:
  - pattern: access(...)
  - pattern: stat(...)
  - pattern: lstat(...)
- id: raptor-insecure-api-alloca
  metadata:
    author: Marco Ivaldi <raptor@0xdeadbeef.info>
    references:
    - https://cwe.mitre.org/data/definitions/676
    - https://cwe.mitre.org/data/definitions/1325
    - https://nullprogram.com/blog/2019/10/28/
    - https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples
    confidence: HIGH
    license: MIT
    category: security
    subcategory:
    - audit
    source: https://github.com/0xdea/semgrep-rules/blob/main/c/insecure-api-alloca.yaml
  message: The program invokes a potentially dangerous function that could introduce
    a vulnerability if it is used incorrectly, but the function can also be used safely.
    Use of alloca() is discouraged. It is unsafe because it cannot ensure that the
    pointer returned points to a valid and usable block of memory. The allocation
    made may exceed the bounds of the stack, or even go further into other objects
    in memory, and alloca() cannot determine such an error.
  severity: WARNING
  languages:
  - c
  - cpp
  pattern: alloca(...)
- id: raptor-insecure-api-atoi-atol-atof
  metadata:
    author: Marco Ivaldi <raptor@0xdeadbeef.info>
    references:
    - https://rules.sonarsource.com/c/type/Bug/RSPEC-989
    confidence: HIGH
    license: MIT
    category: security
    subcategory:
    - audit
    source: https://github.com/0xdea/semgrep-rules/blob/main/c/insecure-api-atoi-atol-atof.yaml
  message: The atoi(), atol(), and atof() functions, which convert strings to numbers,
    have undefined behavior when the strings cannot be converted, and should therefore
    be avoided.
  severity: WARNING
  languages:
  - c
  - cpp
  pattern-either:
  - pattern: atoi(...)
  - pattern: atol(...)
  - pattern: atof(...)
- id: raptor-insecure-api-gets
  metadata:
    author: Marco Ivaldi <raptor@0xdeadbeef.info>
    references:
    - https://cwe.mitre.org/data/definitions/242
    - https://cwe.mitre.org/data/definitions/120
    confidence: HIGH
    license: MIT
    category: security
    subcategory:
    - audit
    source: https://github.com/0xdea/semgrep-rules/blob/main/c/insecure-api-gets.yaml
  message: The program calls a function that can never be guaranteed to work safely.
    Certain functions behave in dangerous ways regardless of how they are used. Functions
    in this category were often implemented without taking security concerns into
    account. The gets() function is unsafe because it does not perform bounds checking
    on the size of its input. An attacker can easily send arbitrarily-sized input
    to gets() and overflow the destination buffer.
  severity: ERROR
  languages:
  - c
  - cpp
  pattern: gets(...)
- id: raptor-insecure-api-mktemp-tmpnam-tempnam
  metadata:
    author: Marco Ivaldi <raptor@0xdeadbeef.info>
    references:
    - https://cwe.mitre.org/data/definitions/377
    - https://cwe.mitre.org/data/definitions/367
    confidence: HIGH
    license: MIT
    category: security
    subcategory:
    - audit
    source: https://github.com/0xdea/semgrep-rules/blob/main/c/insecure-api-mktemp-tmpnam-tempnam.yaml
  message: Creating and using insecure temporary files can leave application and system
    data vulnerable to attack.
  severity: WARNING
  languages:
  - c
  - cpp
  pattern-either:
  - pattern: mktemp(...)
  - pattern: tmpnam(...)
  - pattern: tempnam(...)
- id: raptor-insecure-api-rand-srand
  metadata:
    author: Marco Ivaldi <raptor@0xdeadbeef.info>
    references:
    - https://cwe.mitre.org/data/definitions/338
    - https://cwe.mitre.org/data/definitions/330
    - https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf
    confidence: HIGH
    license: MIT
    category: security
    subcategory:
    - audit
    source: https://github.com/0xdea/semgrep-rules/blob/main/c/insecure-api-rand-srand.yaml
  message: The software uses a Pseudo-Random Number Generator (PRNG) in a security
    context, but the PRNG's algorithm is not cryptographically strong. When a non-cryptographic
    PRNG is used in a cryptographic context, it can expose the cryptography to certain
    types of attacks. Often a pseudo-random number generator (PRNG) is not designed
    for cryptography. Sometimes a mediocre source of randomness is sufficient or preferable
    for algorithms that use random numbers. Weak generators generally take less processing
    power and/or do not use the precious, finite, entropy sources on a system. While
    such PRNGs might have very useful features, these same features could be used
    to break the cryptography.
  severity: WARNING
  languages:
  - c
  - cpp
  pattern-either:
  - pattern: rand(...)
  - pattern: srand(...)
- id: raptor-insecure-api-scanf-etc
  metadata:
    author: Marco Ivaldi <raptor@0xdeadbeef.info>
    references:
    - https://cwe.mitre.org/data/definitions/676
    - https://cwe.mitre.org/data/definitions/120
    - https://cwe.mitre.org/data/definitions/787
    - https://g.co/kgs/PCHQjJ
    confidence: HIGH
    license: MIT
    category: security
    subcategory:
    - audit
    source: https://github.com/0xdea/semgrep-rules/blob/main/c/insecure-api-scanf-etc.yaml
  message: The program invokes a potentially dangerous function that could introduce
    a vulnerability if it is used incorrectly, but the function can also be used safely.
    A buffer overflow condition exists when a program attempts to put more data in
    a buffer than it can hold, or when a program attempts to put data in a memory
    area outside of the boundaries of a buffer. The simplest type of error, and the
    most common cause of buffer overflows, is the classic case in which the program
    copies the buffer without restricting how much is copied. Other variants exist,
    but the existence of a classic overflow strongly suggests that the programmer
    is not considering even the most basic of security protections.
  severity: WARNING
  languages:
  - c
  - cpp
  patterns:
  - pattern-either:
    - pattern: scanf($FMT, ...)
    - pattern: vscanf($FMT, ...)
    - pattern: fscanf($FS, $FMT, ...)
    - pattern: vfscanf($FS, $FMT, ...)
    - pattern: sscanf($BUF, $FMT, ...)
    - pattern: vsscanf($BUF, $FMT, ...)
    - pattern: wscanf($FMT, ...)
    - pattern: vwscanf($FMT, ...)
    - pattern: fwscanf($FS, $FMT, ...)
    - pattern: vfwscanf($FS, $FMT, ...)
    - pattern: swscanf($BUF, $FMT, ...)
    - pattern: vswscanf($BUF, $FMT, ...)
  - metavariable-regex:
      metavariable: "$FMT"
      regex: (".*%l?s.*"|".*%S.*"|[a-zA-Z_][a-zA-Z0-9_]*)
- id: raptor-insecure-api-sprintf-vsprintf
  metadata:
    author: Marco Ivaldi <raptor@0xdeadbeef.info>
    references:
    - https://cwe.mitre.org/data/definitions/676
    - https://cwe.mitre.org/data/definitions/120
    - https://cwe.mitre.org/data/definitions/787
    - https://g.co/kgs/PCHQjJ
    confidence: HIGH
    license: MIT
    category: security
    subcategory:
    - audit
    source: https://github.com/0xdea/semgrep-rules/blob/main/c/insecure-api-sprintf-vsprintf.yaml
  message: The program invokes a potentially dangerous function that could introduce
    a vulnerability if it is used incorrectly, but the function can also be used safely.
    A buffer overflow condition exists when a program attempts to put more data in
    a buffer than it can hold, or when a program attempts to put data in a memory
    area outside of the boundaries of a buffer. The simplest type of error, and the
    most common cause of buffer overflows, is the classic case in which the program
    copies the buffer without restricting how much is copied. Other variants exist,
    but the existence of a classic overflow strongly suggests that the programmer
    is not considering even the most basic of security protections.
  severity: WARNING
  languages:
  - c
  - cpp
  patterns:
  - pattern-either:
    - pattern: sprintf($BUF, $FMT, ...)
    - pattern: vsprintf($BUF, $FMT, ...)
  - metavariable-regex:
      metavariable: "$FMT"
      regex: (".*%l?s.*"|".*%S.*"|[a-zA-Z_][a-zA-Z0-9_]*)
- id: raptor-insecure-api-strcpy-stpcpy-strcat
  metadata:
    author: Marco Ivaldi <raptor@0xdeadbeef.info>
    references:
    - https://cwe.mitre.org/data/definitions/676
    - https://cwe.mitre.org/data/definitions/120
    - https://cwe.mitre.org/data/definitions/787
    - https://g.co/kgs/PCHQjJ
    confidence: HIGH
    license: MIT
    category: security
    subcategory:
    - audit
    source: https://github.com/0xdea/semgrep-rules/blob/main/c/insecure-api-strcpy-stpcpy-strcat.yaml
  message: The program invokes a potentially dangerous function that could introduce
    a vulnerability if it is used incorrectly, but the function can also be used safely.
    A buffer overflow condition exists when a program attempts to put more data in
    a buffer than it can hold, or when a program attempts to put data in a memory
    area outside of the boundaries of a buffer. The simplest type of error, and the
    most common cause of buffer overflows, is the classic case in which the program
    copies the buffer without restricting how much is copied. Other variants exist,
    but the existence of a classic overflow strongly suggests that the programmer
    is not considering even the most basic of security protections.
  severity: WARNING
  languages:
  - c
  - cpp
  patterns:
  - pattern-either:
    - pattern: strcpy(...)
    - pattern: stpcpy(...)
    - pattern: strcat(...)
    - pattern: wcscpy(...)
    - pattern: wcpcpy(...)
    - pattern: wcscat(...)
  - pattern-not: $FUN($BUF, "...", ...)
- id: raptor-integer-truncation
  metadata:
    author: Marco Ivaldi <raptor@0xdeadbeef.info>
    references:
    - https://cwe.mitre.org/data/definitions/197
    - https://cwe.mitre.org/data/definitions/681
    - https://g.co/kgs/PCHQjJ
    - https://github.com/struct/mms
    confidence: MEDIUM
    license: MIT
    category: security
    subcategory:
    - audit
    source: https://github.com/0xdea/semgrep-rules/blob/main/c/integer-truncation.yaml
  message: Truncation errors occur when a primitive is cast to a primitive of a smaller
    size and data is lost in the conversion. When a primitive is cast to a smaller
    primitive, the high order bits of the large value are lost in the conversion,
    potentially resulting in an unexpected value that is not equal to the original
    value. This value may be required as an index into a buffer, a loop iterator,
    or simply necessary state data. In any case, the value cannot be trusted and the
    system will be in an undefined state. While this method may be employed viably
    to isolate the low bits of a value, this usage is rare, and truncation usually
    implies that an implementation error has occurred.
  severity: WARNING
  languages:
  - c
  - cpp
  pattern-either:
  - pattern: "(char $NARROW) = <... (short $LARGE) ...>"
  - pattern: "(char $NARROW) = <... (short int $LARGE) ...>"
  - pattern: "(char $NARROW) = <... (unsigned short $LARGE) ...>"
  - pattern: "(char $NARROW) = <... (unsigned short int $LARGE) ...>"
  - pattern: "(char $NARROW) = <... (int $LARGE) ...>"
  - pattern: "(char $NARROW) = <... (unsigned $LARGE) ...>"
  - pattern: "(char $NARROW) = <... (unsigned int $LARGE) ...>"
  - pattern: "(char $NARROW) = <... (long $LARGE) ...>"
  - pattern: "(char $NARROW) = <... (long int $LARGE) ...>"
  - pattern: "(char $NARROW) = <... (unsigned long $LARGE) ...>"
  - pattern: "(char $NARROW) = <... (unsigned long int $LARGE) ...>"
  - pattern: |
      char $FUN(...)
      {
      ...
      return (short $LARGE);
      }
  - pattern: |
      char $FUN(...)
      {
      ...
      return (int $LARGE);
      }
  - pattern: |
      char $FUN(...)
      {
      ...
      return (long $LARGE);
      }
  - pattern: "(short $NARROW) = <... (unsigned short $LARGE) ...>"
  - pattern: "(short int $NARROW) = <... (unsigned short int $LARGE) ...>"
  - pattern: "(short $NARROW) = <... (int $LARGE) ...>"
  - pattern: "(short $NARROW) = <... (unsigned $LARGE) ...>"
  - pattern: "(short int $NARROW) = <... (unsigned int $LARGE) ...>"
  - pattern: "(short $NARROW) = <... (long $LARGE) ...>"
  - pattern: "(short int $NARROW) = <... (long int $LARGE) ...>"
  - pattern: "(short $NARROW) = <... (unsigned long $LARGE) ...>"
  - pattern: "(short int $NARROW) = <... (unsigned long int $LARGE) ...>"
  - pattern: "(unsigned short $NARROW) = <... (int $LARGE) ...>"
  - pattern: "(unsigned short $NARROW) = <... (unsigned $LARGE) ...>"
  - pattern: "(unsigned short int $NARROW) = <... (unsigned int $LARGE) ...>"
  - pattern: "(unsigned short $NARROW) = <... (long $LARGE) ...>"
  - pattern: "(unsigned short int $NARROW) = <... (long int $LARGE) ...>"
  - pattern: "(unsigned short $NARROW) = <... (unsigned long $LARGE) ...>"
  - pattern: "(unsigned short int $NARROW) = <... (unsigned long int $LARGE) ...>"
  - pattern: |
      short $FUN(...)
      {
      ...
      return (int $LARGE);
      }
  - pattern: |
      short $FUN(...)
      {
      ...
      return (long $LARGE);
      }
  - pattern: "(int $NARROW) = <... (unsigned $LARGE) ...>"
  - pattern: "(int $NARROW) = <... (unsigned int $LARGE) ...>"
  - pattern: "(int $NARROW) = <... (long $LARGE) ...>"
  - pattern: "(int $NARROW) = <... (long int $LARGE) ...>"
  - pattern: "(int $NARROW) = <... (unsigned long $LARGE) ...>"
  - pattern: "(int $NARROW) = <... (unsigned long int $LARGE) ...>"
  - pattern: |
      int $FUN(...)
      {
      ...
      return (long $LARGE);
      }
  - pattern: "(long $NARROW) = <... (unsigned long $LARGE) ...>"
  - pattern: "(long int $NARROW) = <... (unsigned long int $LARGE) ...>"
- id: raptor-integer-wraparound
  metadata:
    author: Marco Ivaldi <raptor@0xdeadbeef.info>
    references:
    - https://cwe.mitre.org/data/definitions/190
    - https://cwe.mitre.org/data/definitions/128
    - https://cwe.mitre.org/data/definitions/131
    - https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf
    - http://www.phrack.org/issues/60/10.html#article
    - https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples
    - https://dustri.org/b/playing-with-weggli.html
    confidence: MEDIUM
    license: MIT
    category: security
    subcategory:
    - audit
    source: https://github.com/0xdea/semgrep-rules/blob/main/c/integer-wraparound.yaml
  message: The software performs a calculation that can produce an integer overflow
    or wraparound, when the logic assumes that the resulting value will always be
    larger than the original value. This can introduce other weaknesses when the calculation
    is used for resource management or execution control. An integer overflow or wraparound
    occurs when an integer value is incremented to a value that is too large to store
    in the associated representation. When this occurs, the value may wrap to become
    a very small or negative number. While this may be intended behavior in circumstances
    that rely on wrapping, it can have security consequences if the wrap is unexpected.
    This is especially the case if the integer overflow can be triggered using user-supplied
    inputs. This becomes security-critical when the result is used to control looping,
    make a security decision, or determine the offset or size in behaviors such as
    memory allocation, copying, concatenation, etc.
  severity: WARNING
  languages:
  - c
  - cpp
  pattern-either:
  - patterns:
    - pattern: "$FUN($X * $Y)"
    - metavariable-pattern:
        metavariable: "$FUN"
        pattern-either:
        - pattern: malloc
        - pattern: valloc
  - patterns:
    - pattern: "$FUN($N)"
    - pattern-inside: |
        $N = $X * $Y;
        ...
    - metavariable-pattern:
        metavariable: "$FUN"
        pattern-either:
        - pattern: malloc
        - pattern: valloc
  - patterns:
    - pattern: "$FUN($ARG1, $X * $Y)"
    - metavariable-pattern:
        metavariable: "$FUN"
        pattern-either:
        - pattern: calloc
        - pattern: realloc
        - pattern: reallocf
        - pattern: aligned_alloc
  - patterns:
    - pattern: "$FUN($ARG1, $N)"
    - pattern-inside: |
        $N = $X * $Y;
        ...
    - metavariable-pattern:
        metavariable: "$FUN"
        pattern-either:
        - pattern: calloc
        - pattern: realloc
        - pattern: reallocf
        - pattern: aligned_alloc
- id: raptor-interesting-api-calls
  metadata:
    author: Marco Ivaldi <raptor@0xdeadbeef.info>
    references:
    - https://github.com/0xdea/ghidra-scripts/blob/main/Rhabdomancer.java
    - https://github.com/x509cert/banned/blob/master/banned.h
    - https://g.co/kgs/PCHQjJ
    - https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf
    confidence: MEDIUM
    license: MIT
    category: security
    subcategory:
    - audit
    source: https://github.com/0xdea/semgrep-rules/blob/main/c/interesting-api-calls.yaml
  message: Locate all calls to interesting and potentially insecure API functions
    (candidate points). The auditor can backtrace from these candidate points to find
    pathways allowing access from untrusted input.
  severity: INFO
  languages:
  - c
  - cpp
  pattern-either:
  - pattern-regex: "\\w*set\\w*(u|g)id\\s*\\(.*"
  - pattern-regex: "\\w*(init|set)groups\\s*\\(.*"
  - pattern-regex: "\\w*str\\w?cpy\\s*\\(.*"
  - pattern-regex: "\\w*stpn?cpy\\s*\\(.*"
  - pattern-regex: "\\w*str\\w?cat\\s*\\(.*"
  - pattern-regex: "\\w*wcs\\w?cpy\\s*\\(.*"
  - pattern-regex: "\\w*wcpn?cpy\\s*\\(.*"
  - pattern-regex: "\\w*wcs\\w?cat\\s*\\(.*"
  - pattern-regex: "\\w*strtok\\s*\\(.*"
  - pattern-regex: "\\w*wcstok\\s*\\(.*"
  - pattern-regex: "\\w*s\\w?printf\\w*\\(.*"
  - pattern-regex: "\\w*sn\\w?printf\\w*\\(.*"
  - pattern-regex: "\\w*scanf\\s*\\(.*"
  - pattern-regex: "\\w*get(s|c|char|pw|pass|wd|cwd|env|opt|opt_long)\\s*\\(.*"
  - pattern-regex: "\\w*memc?cpy\\s*\\(.*"
  - pattern-regex: "\\w*mem(move|set)\\s*\\(.*"
  - pattern-regex: "\\w*bcopy\\s*\\(.*"
  - pattern-regex: "\\w*alloca\\s*\\(.*"
  - pattern-regex: "\\w*exec(l|v)?(p|e)?e?\\s*\\(.*"
  - pattern-regex: "\\w*system\\s*\\(.*"
  - pattern-regex: "\\w*open(at)?(64)?\\s*\\(.*"
  - pattern-regex: "\\w*pipe\\s*\\(.*"
  - pattern-regex: "\\w*connect\\s*\\(.*"
  - pattern-regex: "\\w*read\\s*\\(.*"
  - pattern-regex: "\\w*recv(from)?\\s*\\(.*"
  - pattern-regex: "\\w*fork\\s*\\(.*"
  - pattern-regex: "\\w*clone\\s*\\(.*"
  - pattern-regex: "\\w*mk\\w?temp(64)?\\s*\\(.*"
  - pattern-regex: "\\w*te?mpnam\\s*\\(.*"
  - pattern-regex: "\\w*tmpfile\\s*\\(.*"
  - pattern-regex: "\\w*mkdir\\s*\\(.*"
  - pattern-regex: "\\w*creat\\s*\\(.*"
  - pattern-regex: "\\w*link(at)?\\s*\\(.*"
  - pattern-regex: "\\w*rename(at)?\\s*\\(.*"
  - pattern-regex: "\\w*access(at)?\\s*\\(.*"
  - pattern-regex: "\\w*stat(at)?\\s*\\(.*"
  - pattern-regex: "\\w*ch(own|mod)(at)?\\s*\\(.*"
  - pattern-regex: "\\w*rand\\s*\\(.*"
  - pattern-regex: "\\w*assert\\s*\\(.*"
- id: raptor-memory-address-exposure
  metadata:
    author: Marco Ivaldi <raptor@0xdeadbeef.info>
    references:
    - https://cwe.mitre.org/data/definitions/200
    - https://cwe.mitre.org/data/definitions/209
    - https://cwe.mitre.org/data/definitions/497
    - https://github.com/struct/mms
    confidence: MEDIUM
    license: MIT
    category: security
    subcategory:
    - audit
    source: https://github.com/0xdea/semgrep-rules/blob/main/c/memory-address-exposure.yaml
  message: The software generates an error message that includes sensitive information
    about its environment, users, or associated data. In particular, exposure of memory
    addresses might defeat ASLR.
  severity: WARNING
  languages:
  - c
  - cpp
  patterns:
  - pattern-either:
    - pattern: printf($FMT, ...)
    - pattern: vprintf($FMT, ...)
    - pattern: wprintf($FMT, ...)
    - pattern: vwprintf($FMT, ...)
    - pattern: vcprintf($FMT, ...)
    - pattern: vcwprintf($FMT, ...)
    - pattern: vscprintf($FMT, ...)
    - pattern: vscwprintf($FMT, ...)
    - pattern: fprintf($ARG1, $FMT, ...)
    - pattern: vfprintf($ARG1, $FMT, ...)
    - pattern: fwprintf($ARG1, $FMT, ...)
    - pattern: vfwprintf($ARG1, $FMT, ...)
    - pattern: sprintf($ARG1, $FMT, ...)
    - pattern: vsprintf($ARG1, $FMT, ...)
    - pattern: asprintf($ARG1, $FMT, ...)
    - pattern: vasprintf($ARG1, $FMT, ...)
    - pattern: dprintf($ARG1, $FMT, ...)
    - pattern: vdprintf($ARG1, $FMT, ...)
    - pattern: wsprintf($ARG1, $FMT, ...)
    - pattern: snprintf($ARG1, $ARG2, $FMT, ...)
    - pattern: vsnprintf($ARG1, $ARG2, $FMT, ...)
    - pattern: swprintf($ARG1, $ARG2, $FMT, ...)
    - pattern: vswprintf($ARG1, $ARG2, $FMT, ...)
  - metavariable-regex:
      metavariable: "$FMT"
      regex: (".*%\w*x.*"|".*%\w*X.*"|".*%\w*p.*")
- id: raptor-mismatched-memory-management
  metadata:
    author: Marco Ivaldi <raptor@0xdeadbeef.info>
    references:
    - https://cwe.mitre.org/data/definitions/762
    - https://cwe.mitre.org/data/definitions/590
    - https://github.com/struct/mms
    confidence: LOW
    license: MIT
    category: security
    subcategory:
    - audit
    source: https://github.com/0xdea/semgrep-rules/blob/main/c/mismatched-memory-management.yaml
  message: The software attempts to return a memory resource to the system, but it
    calls a release function that is not compatible with the function that was originally
    used to allocate that resource. When the memory management functions are mismatched,
    the consequences may be as severe as code execution, memory corruption, or program
    crash. Consequences and ease of exploit will vary depending on the implementation
    of the routines and the object being managed. Due to inherent limitations of Semgrep,
    this rule might generate many false positives and should therefore be customized
    for your codebase.
  severity: WARNING
  languages:
  - c
  - cpp
  pattern-either:
  - patterns:
    - pattern: free($PTR);
    - pattern-not-inside: |
        $PTR = malloc(...);
        ...
        free($PTR);
    - pattern-not-inside: |
        $PTR = ($CAST)malloc(...);
        ...
        free($PTR);
    - pattern-not-inside: |
        $PTR = calloc(...);
        ...
        free($PTR);
    - pattern-not-inside: |
        $PTR = ($CAST)calloc(...);
        ...
        free($PTR);
    - pattern-not-inside: |
        $PTR = realloc(...);
        ...
        free($PTR);
    - pattern-not-inside: "$PTR = ($CAST)realloc(...);\n...\nfree($PTR); \n"
- id: raptor-mismatched-memory-management-cpp
  metadata:
    author: Marco Ivaldi <raptor@0xdeadbeef.info>
    references:
    - https://cwe.mitre.org/data/definitions/762
    - https://cwe.mitre.org/data/definitions/590
    - https://github.com/struct/mms
    - https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples
    confidence: LOW
    license: MIT
    category: security
    subcategory:
    - audit
    source: https://github.com/0xdea/semgrep-rules/blob/main/c/mismatched-memory-management-cpp.yaml
  message: The software attempts to return a memory resource to the system, but it
    calls a release function that is not compatible with the function that was originally
    used to allocate that resource. When the memory management functions are mismatched,
    the consequences may be as severe as code execution, memory corruption, or program
    crash. Consequences and ease of exploit will vary depending on the implementation
    of the routines and the object being managed. Due to inherent limitations of Semgrep,
    this rule might generate many false positives and should therefore be customized
    for your codebase.
  severity: WARNING
  languages:
  - cpp
  pattern-either:
  - patterns:
    - pattern: free($PTR);
    - pattern-not-inside: |
        $PTR = malloc(...);
        ...
        free($PTR);
    - pattern-not-inside: |
        $PTR = ($CAST)malloc(...);
        ...
        free($PTR);
    - pattern-not-inside: |
        $PTR = calloc(...);
        ...
        free($PTR);
    - pattern-not-inside: |
        $PTR = ($CAST)calloc(...);
        ...
        free($PTR);
    - pattern-not-inside: |
        $PTR = realloc(...);
        ...
        free($PTR);
    - pattern-not-inside: "$PTR = ($CAST)realloc(...);\n...\nfree($PTR); \n"
  - patterns:
    - pattern: delete[]($PTR);
    - pattern-not-inside: |
        $PTR = new $OBJ[$SIZE];
        ...
        delete[]($PTR);
  - patterns:
    - pattern: delete($PTR);
    - pattern-not-inside: |
        $PTR = new $OBJ;
        ...
        delete($PTR);
  - patterns:
    - pattern: delete($PTR);
    - pattern-inside: |
        $PTR = new $OBJ[$SIZE];
        ...
        delete($PTR);
- id: raptor-off-by-one
  metadata:
    author: Marco Ivaldi <raptor@0xdeadbeef.info>
    references:
    - https://cwe.mitre.org/data/definitions/193
    - https://cwe.mitre.org/data/definitions/787
    - https://g.co/kgs/PCHQjJ
    - https://github.com/struct/mms
    confidence: MEDIUM
    license: MIT
    category: security
    subcategory:
    - audit
    source: https://github.com/0xdea/semgrep-rules/blob/main/c/off-by-one.yaml
  message: The software calculates or uses an incorrect maximum or minimum value that
    is 1 more, or 1 less, than the correct value.
  severity: WARNING
  languages:
  - c
  - cpp
  pattern-either:
  - pattern: "$BUF[sizeof($BUF)] = $EXPR"
  - patterns:
    - pattern: "$BUF[$SIZE] = $EXPR"
    - pattern-inside: |
        $TYPE $BUF[$SIZE];
        ...
        $BUF[$SIZE] = $EXPR;
  - pattern: for (<... $I = 0 ...>; <... $I <= $SIZE ...>; <... $I++ ...>) ...
  - pattern: for ($TYPE $I = 0; <... $I <= $SIZE ...>; <... $I++ ...>) ...
  - pattern: while (<... $I <= $SIZE ...>) ...
  - pattern: do ... while (<... $I <= $SIZE ...>);
  - pattern: strlen($SRC) > sizeof($DST)
  - pattern: strlen($SRC) <= sizeof($DST)
  - pattern: sizeof($DST) < strlen($SRC)
  - pattern: sizeof($DST) >= strlen($SRC)
  - patterns:
    - pattern: strncat($DST, $SRC, $LEN)
    - metavariable-pattern:
        metavariable: "$LEN"
        patterns:
        - pattern-not: "$VAL - 1"
- id: raptor-pointer-subtraction
  metadata:
    author: Marco Ivaldi <raptor@0xdeadbeef.info>
    references:
    - https://cwe.mitre.org/data/definitions/469
    - https://github.com/struct/mms
    confidence: MEDIUM
    license: MIT
    category: security
    subcategory:
    - audit
    source: https://github.com/0xdea/semgrep-rules/blob/main/c/pointer-subtraction.yaml
  message: The software subtracts one pointer from another in order to determine size,
    but this calculation can be incorrect if the pointers do not exist in the same
    memory chunk.
  severity: WARNING
  languages:
  - c
  - cpp
  pattern-either:
  - pattern: "(char * $PTR1) - (char * $PTR2)"
  - pattern: "(int * $PTR1) - (int * $PTR2)"
  - pattern: "(float * $PTR1) - (float * $PTR2)"
  - pattern: "(double * $PTR1) - (double * $PTR2)"
  - patterns:
    - pattern-either:
      - pattern: "$PTR1 - $PTR2"
      - pattern: "$PTR2 - $PTR1"
    - pattern-either:
      - pattern-inside: |
          $TYPE * $PTR1;
          $TYPE * $PTR2;
          ...
      - pattern-inside: |
          $TYPE * $PTR1 = $EXPR1;
          $TYPE * $PTR2 = $EXPR2;
          ...
      - pattern-inside: |
          $TYPE * $PTR1 = $EXPR1;
          $TYPE * $PTR2;
          ...
      - pattern-inside: |
          $TYPE * $PTR1;
          $TYPE * $PTR2 = $EXPR2;
          ...
      - pattern-inside: |
          $TYPE * $PTR3 = $PTR1;
          $TYPE * $PTR2;
          ...
      - pattern-inside: |
          $TYPE * $PTR2;
          $TYPE * $PTR3 = $PTR1;
          ...
- id: raptor-ret-stack-address
  metadata:
    author: Marco Ivaldi <raptor@0xdeadbeef.info>
    references:
    - https://cwe.mitre.org/data/definitions/562
    - https://github.com/struct/mms
    - https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf
    - https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples
    - https://rules.sonarsource.com/c/type/Bug/RSPEC-946
    confidence: MEDIUM
    license: MIT
    category: security
    subcategory:
    - audit
    source: https://github.com/0xdea/semgrep-rules/blob/main/c/ret-stack-address.yaml
  message: A function returns the address of a stack variable, which will cause unintended
    program behavior, typically in the form of a crash. Because local variables are
    allocated on the stack, when a program returns a pointer to a local variable,
    it is returning a stack address. A subsequent function call is likely to re-use
    this same stack address, thereby overwriting the value of the pointer, which no
    longer corresponds to the same variable since a function's stack frame is invalidated
    when it returns. At best this will cause the value of the pointer to change unexpectedly.
    In many cases it causes the program to crash the next time the pointer is dereferenced.
  severity: WARNING
  languages:
  - c
  - cpp
  pattern-either:
  - patterns:
    - pattern: return $PTR;
    - pattern-either:
      - pattern-inside: |
          $TYPE $PTR[$SIZE];
          ...
      - pattern-inside: |
          $TYPE $PTR[$SIZE] = $EXPR;
          ...
      - pattern-inside: |
          $TYPE $ARR[$SIZE];
          ...
          $PTR = $ARR;
          ...
      - pattern-inside: |
          $TYPE $ARR[$SIZE] = $EXPR;
          ...
          $PTR = $ARR;
          ...
  - patterns:
    - pattern: return &$VAR;
    - pattern-either:
      - pattern-inside: |
          $TYPE $VAR;
          ...
      - pattern-inside: |
          $TYPE $VAR = $EXPR;
          ...
- id: raptor-signed-unsigned-conversion
  metadata:
    author: Marco Ivaldi <raptor@0xdeadbeef.info>
    references:
    - https://cwe.mitre.org/data/definitions/195
    - https://cwe.mitre.org/data/definitions/196
    - https://cwe.mitre.org/data/definitions/194
    - https://cwe.mitre.org/data/definitions/191
    - https://cwe.mitre.org/data/definitions/681
    - https://cwe.mitre.org/data/definitions/789
    - https://g.co/kgs/PCHQjJ
    - https://github.com/struct/mms
    - https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf
    - http://www.phrack.org/issues/60/10.html#article
    - https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples
    confidence: MEDIUM
    license: MIT
    category: security
    subcategory:
    - audit
    source: https://github.com/0xdea/semgrep-rules/blob/main/c/signed-unsigned-conversion.yaml
  message: The software uses a signed primitive and performs a cast to an unsigned
    primitive, or uses an unsigned primitive and performs a cast to a signed primitive,
    which can produce an unexpected value if the value of the signed primitive cannot
    be represented using an unsigned primitive, or if the value of the unsigned primitive
    cannot be represented using a signed primitive. It is dangerous to rely on implicit
    casts between signed and unsigned numbers because the result can take on an unexpected
    value and violate assumptions made by the program. Often, functions will return
    negative values to indicate a failure. When the result of a function is to be
    used as a size parameter, using these negative return values can have unexpected
    results. For example, if negative size values are passed to the standard memory
    copy or allocation functions they will be implicitly cast to a large unsigned
    value. This may lead to an exploitable buffer overflow or underflow condition.
    Although less frequent an issue than signed-to-unsigned conversion, unsigned-to-signed
    conversion can be the perfect precursor to dangerous buffer underwrite conditions
    that allow attackers to move down the stack where they otherwise might not have
    access in a normal buffer overflow condition. Buffer underwrites occur frequently
    when large unsigned values are cast to signed values, and then used as indexes
    into a buffer or for pointer arithmetic.
  severity: WARNING
  languages:
  - c
  - cpp
  pattern-either:
  - pattern: "(unsigned int $UNSIGNED) = <... (int $SIGNED) ...>"
  - pattern: |
      unsigned int $FUN(...)
      {
      ...
      return (int $SIGNED);
      }
  - pattern: "(unsigned $UNSIGNED) = <... (int $SIGNED) ...>"
  - pattern: |
      unsigned $FUN(...)
      {
      ...
      return (int $SIGNED);
      }
  - pattern: "(size_t $UNSIGNED) = <... (int $SIGNED) ...>"
  - pattern: |
      size_t $FUN(...)
      {
      ...
      return (int $SIGNED);
      }
  - pattern: "(size_t $UNSIGNED) = <... (off_t $SIGNED) ...>"
  - pattern: |
      size_t $FUN(...)
      {
      ...
      return (off_t $SIGNED);
      }
  - pattern: strncpy($DST, $SRC, (int $LEN))
  - pattern: stpncpy($DST, $SRC, (int $LEN))
  - pattern: strncat($DST, $SRC, (int $LEN))
  - pattern: strlcpy($DST, $SRC, (int $LEN))
  - pattern: strlcat($DST, $SRC, (int $LEN))
  - pattern: snprintf($BUF, (int $LEN), ...)
  - pattern: vsnprintf($BUF, (int $LEN), ...)
  - pattern: getcwd($BUF, (int $LEN))
  - pattern: memcpy($DST, $SRC, (int $LEN))
  - pattern: memccpy($DST, $SRC, $CHAR, (int $LEN))
  - pattern: memmove($DST, $SRC, (int $LEN))
  - pattern: memset($DST, $CHAR, (int $LEN))
  - pattern: bcopy($SRC, $DST, (int $LEN))
  - pattern: alloca((int $LEN))
  - pattern: malloc((int $LEN))
  - pattern: calloc($CNT, (int $LEN))
  - pattern: calloc((int $CNT), $LEN)
  - pattern: realloc($PTR, (int $LEN))
  - pattern: read($FD, $BUF, (int $LEN))
  - pattern: recv($SD, $BUF, (int $LEN), $FL)
  - pattern: recvfrom($SD, $BUF, (int $LEN), $FL, ...)
  - pattern: "(int $SIGNED) = <... (unsigned int $UNSIGNED) ...>"
  - pattern: |
      int $FUN(...)
      {
      ...
      return (unsigned int $UNSIGNED);
      }
  - pattern: "(int $SIGNED) = <... (unsigned $UNSIGNED) ...>"
  - pattern: |
      int $FUN(...)
      {
      ...
      return (unsigned $UNSIGNED);
      }
  - pattern: "(int $SIGNED) = <... (size_t $UNSIGNED) ...>"
  - pattern: |
      int $FUN(...)
      {
      ...
      return (size_t $UNSIGNED);
      }
  - pattern: "(off_t $SIGNED) = <... (size_t $UNSIGNED) ...>"
  - pattern: |
      off_t $FUN(...)
      {
      ...
      return (size_t $UNSIGNED);
      }
- id: raptor-unchecked-ret-malloc-calloc-realloc
  metadata:
    author: Marco Ivaldi <raptor@0xdeadbeef.info>
    references:
    - https://cwe.mitre.org/data/definitions/252
    - https://cwe.mitre.org/data/definitions/690
    - https://g.co/kgs/PCHQjJ
    - https://github.com/struct/mms
    - https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf
    confidence: MEDIUM
    license: MIT
    category: security
    subcategory:
    - audit
    source: https://github.com/0xdea/semgrep-rules/blob/main/c/unchecked-ret-malloc-calloc-realloc.yaml
  message: The software does not check the return value from a method or function,
    which can prevent it from detecting unexpected states and conditions. The software
    does not check for an error after calling a function that can return with a NULL
    pointer if the function fails, which leads to a resultant NULL pointer dereference
    or, in some cases, even arbitrary code execution.
  severity: WARNING
  languages:
  - c
  - cpp
  pattern-either:
  - patterns:
    - pattern-either:
      - pattern: "$RET = malloc(...)"
      - pattern: "$RET = ($CAST)malloc(...)"
    - pattern-not-inside: |
        malloc(...);
        ...
        if (<... $RET == NULL ...>) ...
    - pattern-not-inside: |
        malloc(...);
        ...
        if (<... $RET != NULL ...>) ...
    - pattern-not-inside: |
        malloc(...);
        ...
        if (<... !$RET ...>) ...
    - pattern-not-inside: |
        malloc(...);
        ...
        if (<... $RET ...>) ...
    - pattern-not-inside: "<... $ALLOC == NULL ...>"
    - pattern-not-inside: "<... $ALLOC != NULL ...>"
    - pattern-not-inside: "<... !$ALLOC ...>"
  - patterns:
    - pattern-either:
      - pattern: "$RET = calloc(...)"
      - pattern: "$RET = ($CAST)calloc(...)"
    - pattern-not-inside: |
        calloc(...);
        ...
        if (<... $RET == NULL ...>) ...
    - pattern-not-inside: |
        calloc(...);
        ...
        if (<... $RET != NULL ...>) ...
    - pattern-not-inside: |
        calloc(...);
        ...
        if (<... !$RET ...>) ...
    - pattern-not-inside: |
        calloc(...);
        ...
        if (<... $RET ...>) ...
    - pattern-not-inside: "<... $ALLOC == NULL ...>"
    - pattern-not-inside: "<... $ALLOC != NULL ...>"
    - pattern-not-inside: "<... !$ALLOC ...>"
  - patterns:
    - pattern-either:
      - pattern: "$RET = realloc(...)"
      - pattern: "$RET = ($CAST)realloc(...)"
    - pattern-not-inside: |
        realloc(...);
        ...
        if (<... $RET == NULL ...>) ...
    - pattern-not-inside: |
        realloc(...);
        ...
        if (<... $RET != NULL ...>) ...
    - pattern-not-inside: |
        realloc(...);
        ...
        if (<... !$RET ...>) ...
    - pattern-not-inside: |
        realloc(...);
        ...
        if (<... $RET ...>) ...
    - pattern-not-inside: "<... $ALLOC == NULL ...>"
    - pattern-not-inside: "<... $ALLOC != NULL ...>"
    - pattern-not-inside: "<... !$ALLOC ...>"
- id: raptor-unchecked-ret-setuid-seteuid
  metadata:
    author: Marco Ivaldi <raptor@0xdeadbeef.info>
    references:
    - https://cwe.mitre.org/data/definitions/252
    - https://lwn.net/Articles/451985/
    - https://www.usenix.org/legacy/events/sec02/full_papers/chen/chen.pdf
    confidence: MEDIUM
    license: MIT
    category: security
    subcategory:
    - audit
    source: https://github.com/0xdea/semgrep-rules/blob/main/c/unchecked-ret-setuid-seteuid.yaml
  message: The software does not check the return value from a method or function,
    which can prevent it from detecting unexpected states and conditions. If an attacker
    can force the function to fail or otherwise return a value that is not expected,
    then the subsequent program logic could lead to a vulnerability, because the software
    is not in a state that the programmer assumes. For example, if the program calls
    a function to drop privileges but does not check the return code to ensure that
    privileges were successfully dropped, then the program will continue to operate
    with the higher privileges.
  severity: WARNING
  languages:
  - c
  - cpp
  pattern-either:
  - patterns:
    - pattern: setuid(...)
    - pattern-not-inside: "$RET = setuid(...)"
    - pattern-not-inside: "<... setuid(...) == $VAL ...>"
    - pattern-not-inside: "<... setuid(...) != $VAL ...>"
    - pattern-not-inside: "<... setuid(...) < $VAL ...>"
    - pattern-not-inside: "<... !setuid(...) ...>"
    - pattern-not-inside: return setuid(...);
  - patterns:
    - pattern: seteuid(...)
    - pattern-not-inside: "$RET = seteuid(...)"
    - pattern-not-inside: "<... seteuid(...) == $VAL ...>"
    - pattern-not-inside: "<... seteuid(...) != $VAL ...>"
    - pattern-not-inside: "<... seteuid(...) < $VAL ...>"
    - pattern-not-inside: "<... !seteuid(...) ...>"
    - pattern-not-inside: return seteuid(...);
- id: raptor-unsafe-ret-snprintf-vsnprintf
  metadata:
    author: Marco Ivaldi <raptor@0xdeadbeef.info>
    references:
    - https://lwn.net/Articles/507319/
    - https://g.co/kgs/PCHQjJ
    - https://dustri.org/b/playing-with-weggli.html
    confidence: MEDIUM
    license: MIT
    category: security
    subcategory:
    - audit
    source: https://github.com/0xdea/semgrep-rules/blob/main/c/unsafe-ret-snprintf-vsnprintf.yaml
  message: The snprintf() and vsnprintf() functions return the total length of the
    string they tried to create. Therefore, this return value can be larger than the
    size of the destination buffer. If it is used unsafely, e.g. as an index to write
    to the destination buffer, memory corruption might occur. Vulnerabilities such
    as this are not common because the return value is usually discarded. However,
    ignoring the result of these functions can result in data truncation.
  severity: WARNING
  languages:
  - c
  - cpp
  pattern-either:
  - pattern: "$RET = snprintf(...)"
  - pattern: "$RET = vsnprintf(...)"
  - pattern: "$RET += snprintf(...)"
  - pattern: "$RET += vsnprintf(...)"
- id: raptor-unsafe-ret-strlcpy-strlcat
  metadata:
    author: Marco Ivaldi <raptor@0xdeadbeef.info>
    references:
    - https://lwn.net/Articles/507319/
    - https://g.co/kgs/PCHQjJ
    confidence: MEDIUM
    license: MIT
    category: security
    subcategory:
    - audit
    source: https://github.com/0xdea/semgrep-rules/blob/main/c/unsafe-ret-strlcpy-strlcat.yaml
  message: The strlcpy() and strlcat() functions return the total length of the string
    they tried to create. For strlcpy() that means the length of the source string.
    For strlcat() that means the initial length of the destination string plus the
    length of of the source string. Therefore, this return value can be larger than
    the size of the destination buffer. If it is used unsafely, e.g. as an index to
    write to the destination buffer, memory corruption might occur. Vulnerabilities
    such as this are not common because the return value is usually discarded. However,
    ignoring the result of these functions can result in data truncation.
  severity: WARNING
  languages:
  - c
  - cpp
  pattern-either:
  - pattern: "$RET = strlcpy(...)"
  - pattern: "$RET = strlcat(...)"
  - pattern: "$RET = wcslcpy(...)"
  - pattern: "$RET = wcslcat(...)"
  - pattern: "$RET += strlcpy(...)"
  - pattern: "$RET += strlcat(...)"
  - pattern: "$RET += wcslcpy(...)"
  - pattern: "$RET += wcslcat(...)"
- id: raptor-unsafe-strlen
  metadata:
    author: Marco Ivaldi <raptor@0xdeadbeef.info>
    references:
    - https://cwe.mitre.org/data/definitions/190
    - https://cwe.mitre.org/data/definitions/680
    - https://github.com/struct/mms
    confidence: MEDIUM
    license: MIT
    category: security
    subcategory:
    - audit
    source: https://github.com/0xdea/semgrep-rules/blob/main/c/unsafe-strlen.yaml
  message: The software performs a calculation that can produce an integer overflow
    or wraparound, when the logic assumes that the resulting value will always be
    larger than the original value. This can introduce other weaknesses when the calculation
    is used for resource management or execution control. An integer overflow or wraparound
    occurs when an integer value is incremented to a value that is too large to store
    in the associated representation. When this occurs, the value may wrap to become
    a very small or negative number. While this may be intended behavior in circumstances
    that rely on wrapping, it can have security consequences if the wrap is unexpected.
    This is especially the case if the integer overflow can be triggered using user-supplied
    inputs. This becomes security-critical when the result is used to control looping,
    make a security decision, or determine the offset or size in behaviors such as
    memory allocation, copying, concatenation, etc. When influenced by the size of
    an input it is often easier to overflow a short than an int.
  severity: WARNING
  languages:
  - c
  - cpp
  pattern-either:
  - pattern: "(short $LEN) = strlen(...);"
  - pattern: "(short int $LEN) = strlen(...);"
  - pattern: "(unsigned short $LEN) = strlen(...);"
  - pattern: "(unsigned short int $LEN) = strlen(...);"
  - pattern: "(short $LEN) = wcslen(...);"
  - pattern: "(short int $LEN) = wcslen(...);"
  - pattern: "(unsigned short $LEN) = wcslen(...);"
  - pattern: "(unsigned short int $LEN) = wcslen(...);"
- id: raptor-unterminated-string-strncpy-stpncpy
  metadata:
    author: Marco Ivaldi <raptor@0xdeadbeef.info>
    references:
    - https://cwe.mitre.org/data/definitions/170
    - https://cwe.mitre.org/data/definitions/126
    - https://g.co/kgs/PCHQjJ
    - https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf
    confidence: MEDIUM
    license: MIT
    category: security
    subcategory:
    - audit
    source: https://github.com/0xdea/semgrep-rules/blob/main/c/unterminated-string-strncpy-stpncpy.yaml
  message: The software does not terminate or incorrectly terminates a string or array
    with a NUL character or equivalent terminator. If there is no NUL character byte
    in the first n bytes of the source string, strncpy() and stpncpy() do not null-terminate
    the destination buffer. If the program does not explicitly terminate the destination
    buffer, this will almost certainly result in information disclosure, and possibly
    a buffer overflow condition, which may be exploited to execute arbitrary code.
  severity: WARNING
  languages:
  - c
  - cpp
  pattern-either:
  - patterns:
    - pattern: strncpy(...)
    - pattern-not-inside: |
        strncpy($DST, $SRC, $N);
        ...
        $DST[$POS] = NULL;
    - pattern-not-inside: |
        strncpy($DST, $SRC, $N);
        ...
        $DST[$POS] = '\0';
    - pattern-not-inside: |
        strncpy($DST, $SRC, $N);
        ...
        $DST[$POS] = 0;
  - patterns:
    - pattern: stpncpy(...)
    - pattern-not-inside: |
        stpncpy($DST, $SRC, $N);
        ...
        $DST[$POS] = NULL;
    - pattern-not-inside: |
        stpncpy($DST, $SRC, $N);
        ...
        $DST[$POS] = '\0';
    - pattern-not-inside: |
        stpncpy($DST, $SRC, $N);
        ...
        $DST[$POS] = 0;
  - patterns:
    - pattern: wcsncpy(...)
    - pattern-not-inside: |
        wcsncpy($DST, $SRC, $N);
        ...
        $DST[$POS] = NULL;
    - pattern-not-inside: |
        wcsncpy($DST, $SRC, $N);
        ...
        $DST[$POS] = '\0';
    - pattern-not-inside: |
        wcsncpy($DST, $SRC, $N);
        ...
        $DST[$POS] = 0;
  - patterns:
    - pattern: wcpncpy(...)
    - pattern-not-inside: |
        wcpncpy($DST, $SRC, $N);
        ...
        $DST[$POS] = NULL;
    - pattern-not-inside: |
        wcpncpy($DST, $SRC, $N);
        ...
        $DST[$POS] = '\0';
    - pattern-not-inside: |
        wcpncpy($DST, $SRC, $N);
        ...
        $DST[$POS] = 0;
- id: raptor-use-after-free
  metadata:
    author: Marco Ivaldi <raptor@0xdeadbeef.info>
    references:
    - https://cwe.mitre.org/data/definitions/416
    - https://github.com/struct/mms
    - https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf
    - https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples
    confidence: MEDIUM
    license: MIT
    category: security
    subcategory:
    - audit
    source: https://github.com/0xdea/semgrep-rules/blob/main/c/use-after-free.yaml
  message: Referencing memory after it has been freed can cause a program to crash,
    use unexpected values, or execute code. The use of previously-freed memory can
    have any number of adverse consequences, ranging from the corruption of valid
    data to the execution of arbitrary code, depending on the instantiation and timing
    of the flaw. The simplest way data corruption may occur involves the system's
    reuse of the freed memory. In this scenario, the memory in question is allocated
    to another pointer validly at some point after it has been freed. The original
    pointer to the freed memory is used again and points to somewhere within the new
    allocation. As the data is changed, it corrupts the validly used memory; this
    induces undefined behavior in the process.
  severity: ERROR
  languages:
  - c
  - cpp
  pattern-either:
  - patterns:
    - pattern: |
        free($PTR);
        ...
        $FUN(..., $PTR, ...);
    - pattern-not: |
        free($PTR);
        ...
        $PTR = $EXPR;
        ...
        $FUN(..., $PTR, ...);
    - metavariable-pattern:
        metavariable: "$FUN"
        patterns:
        - pattern-not: free
  - patterns:
    - pattern: |
        free($PTR);
        ...
        $FUN(..., $PTR->$MEM, ...);
    - pattern-not: |
        free($PTR);
        ...
        $PTR = $EXPR;
        ...
        $FUN(..., $PTR->$MEM, ...);
  - patterns:
    - pattern: |
        free($PTR);
        ...
        $PTR->$FUN(...);
    - pattern-not: |
        free($PTR);
        ...
        $PTR = $EXPR;
        ...
        $PTR->$FUN(...);
  - patterns:
    - pattern: |
        free($PTR);
        ...
        return $PTR;
    - pattern-not: |
        free($PTR);
        ...
        $PTR = $EXPR;
        ...
        return $PTR;
  - patterns:
    - pattern: |
        free($PTR);
        ...
        return $PTR[$POS];
    - pattern-not: |
        free($PTR);
        ...
        $PTR = $EXPR;
        ...
        return $PTR;
- id: raptor-write-into-stack-buffer
  metadata:
    author: Marco Ivaldi <raptor@0xdeadbeef.info>
    references:
    - https://cwe.mitre.org/data/definitions/121
    - https://github.com/googleprojectzero/weggli
    confidence: LOW
    license: MIT
    category: security
    subcategory:
    - audit
    source: https://github.com/0xdea/semgrep-rules/blob/main/c/write-into-stack-buffer.yaml
  message: The software directly writes into a stack buffer. This might lead to a
    stack-based buffer overflow.
  severity: INFO
  languages:
  - c
  - cpp
  pattern-either:
  - patterns:
    - pattern: "$FUN($BUF, ...)"
    - pattern-inside: |
        $TYPE $BUF[$SIZE];
        ...
        $FUN($BUF, ...);
    - pattern-not: $FUN($BUF, "...", ...)
    - metavariable-pattern:
        metavariable: "$FUN"
        pattern-either:
        - pattern: strcpy
        - pattern: strncpy
        - pattern: stpcpy
        - pattern: stpncpy
        - pattern: strlcpy
        - pattern: wcscpy
        - pattern: wcsncpy
        - pattern: wcpcpy
        - pattern: wcpncpy
        - pattern: wcslcpy
        - pattern: strcat
        - pattern: strncat
        - pattern: strlcat
        - pattern: wcscat
        - pattern: wcsncat
        - pattern: wcslcat
        - pattern: memcpy
        - pattern: memccpy
        - pattern: memmove
        - pattern: memset
        - pattern: wmemcpy
        - pattern: wmemmove
        - pattern: wmemset
  - patterns:
    - pattern: "$FUN($BUF, $FMT, ...)"
    - pattern-inside: |
        $TYPE $BUF[$SIZE];
        ...
        $FUN($BUF, $FMT, ...);
    - metavariable-regex:
        metavariable: "$FMT"
        regex: (".*%l?s.*"|".*%S.*"|[a-zA-Z_][a-zA-Z0-9_]*)
    - metavariable-pattern:
        metavariable: "$FUN"
        pattern-either:
        - pattern: sprintf
        - pattern: vsprintf
  - patterns:
    - pattern: "$FUN($BUF, $LEN, $FMT, ...)"
    - pattern-inside: |
        $TYPE $BUF[$SIZE];
        ...
        $FUN($BUF, $LEN, $FMT, ...);
    - metavariable-regex:
        metavariable: "$FMT"
        regex: (".*%l?s.*"|".*%S.*"|[a-zA-Z_][a-zA-Z0-9_]*)
    - metavariable-pattern:
        metavariable: "$FUN"
        pattern-either:
        - pattern: snprintf
        - pattern: vsnprintf
  - patterns:
    - pattern: "$FUN($BUF, ...)"
    - pattern-inside: |
        $TYPE $BUF[$SIZE];
        ...
        $FUN($BUF, ...);
    - metavariable-pattern:
        metavariable: "$FUN"
        pattern-either:
        - pattern: gets
        - pattern: fgets
        - pattern: getwd
        - pattern: getcwd
  - patterns:
    - pattern: "$FUN($ARG1, $BUF, ...)"
    - pattern-inside: |
        $TYPE $BUF[$SIZE];
        ...
        $FUN($ARG1, $BUF, ...);
    - pattern-not: $FUN("...", $BUF, ...)
    - metavariable-pattern:
        metavariable: "$FUN"
        pattern-either:
        - pattern: bcopy
  - patterns:
    - pattern: "$FUN($ARG1, $BUF, ...)"
    - pattern-inside: |
        $TYPE $BUF[$SIZE];
        ...
        $FUN($ARG1, $BUF, ...);
    - metavariable-pattern:
        metavariable: "$FUN"
        pattern-either:
        - pattern: read
        - pattern: pread
        - pattern: recv
        - pattern: recvfrom
